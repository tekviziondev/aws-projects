"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processFlowAction = exports.processRootFlowBlock = exports.processFlow = void 0;
const contact_flow_loader_1 = require("./contact-flow-loader");
const call_recording_1 = require("./SMA_Mapping_Actions/call-recording");
const compare_attribute_1 = require("./SMA_Mapping_Actions/compare-attribute");
const disconnect_participant_1 = require("./SMA_Mapping_Actions/disconnect-participant");
const end_module_1 = require("./SMA_Mapping_Actions/end-module");
const get_participant_input_1 = require("./SMA_Mapping_Actions/get-participant-input");
const invoke_lambda_1 = require("./SMA_Mapping_Actions/invoke-lambda");
const invoke_module_1 = require("./SMA_Mapping_Actions/invoke-module");
const lex_bot_1 = require("./SMA_Mapping_Actions/lex-bot");
const loop_1 = require("./SMA_Mapping_Actions/loop");
const message_participant_1 = require("./SMA_Mapping_Actions/message-participant");
const set_voice_1 = require("./SMA_Mapping_Actions/set-voice");
const transfer_flow_1 = require("./SMA_Mapping_Actions/transfer-flow");
const transfer_to_thirdparty_1 = require("./SMA_Mapping_Actions/transfer-to-thirdparty");
const update_contact_attributes_1 = require("./SMA_Mapping_Actions/update-contact-attributes");
const wait_1 = require("./SMA_Mapping_Actions/wait");
const amazon_connect_actionTypes_1 = require("./utility/amazon-connect-actionTypes");
const call_details_1 = require("./utility/call-details");
const condition_validation_1 = require("./utility/condition-validation");
const constant_values_1 = require("./utility/constant-values");
const error_types_1 = require("./utility/error-types");
const event_types_1 = require("./utility/event-types");
const find_action_id_1 = require("./utility/find-action-id");
const next_action_error_1 = require("./utility/next-action-error");
const termination_action_1 = require("./utility/termination-action");
const connectContextStore = "ConnectContextStore";
/**
  * This function get connect flow data from contact flow loader
  * and send the connect flow data to respective functions.
  * @param smaEvent
  * @param amazonConnectInstanceID
  * @param amazonConnectFlowID
  * @param bucketName
  * @returns SMA Action
  */
async function processFlow(smaEvent, amazonConnectInstanceID, amazonConnectFlowID, bucketName) {
    let callId;
    let contextStore = {};
    try {
        let type = "Contact_Flow";
        const transactionAttributes = smaEvent.CallDetails.TransactionAttributes;
        if (transactionAttributes && transactionAttributes[constant_values_1.Attributes.CONNECT_CONTEXT_STORE]) {
            contextStore = transactionAttributes[constant_values_1.Attributes.CONNECT_CONTEXT_STORE];
        }
        if (transactionAttributes && transactionAttributes[constant_values_1.Attributes.CONNECT_CONTEXT_STORE] && !transactionAttributes[constant_values_1.Attributes.CONNECT_CONTEXT_STORE]['ActualFlowARN']) {
            transactionAttributes[constant_values_1.Attributes.CONNECT_CONTEXT_STORE]['ActualFlowARN'] = amazonConnectFlowID;
        }
        if (transactionAttributes && transactionAttributes[constant_values_1.Attributes.CONNECT_CONTEXT_STORE] && transactionAttributes[constant_values_1.Attributes.CONNECT_CONTEXT_STORE]['TransferFlowARN']) {
            amazonConnectFlowID = transactionAttributes[constant_values_1.Attributes.CONNECT_CONTEXT_STORE]['TransferFlowARN'];
        }
        if (transactionAttributes && transactionAttributes[constant_values_1.Attributes.CONNECT_CONTEXT_STORE] && transactionAttributes[constant_values_1.Attributes.CONNECT_CONTEXT_STORE]['InvokeModuleARN']) {
            type = "Invoke_Module";
            amazonConnectFlowID = transactionAttributes[constant_values_1.Attributes.CONNECT_CONTEXT_STORE]['InvokeModuleARN'];
        }
        const legA = (0, call_details_1.getLegACallDetails)(smaEvent);
        callId = legA.CallId;
        if (!callId)
            callId = smaEvent.ActionData.Parameters.CallId;
        const contactFlow = await (0, contact_flow_loader_1.loadContactFlow)(amazonConnectInstanceID, amazonConnectFlowID, bucketName, smaEvent, type);
        console.log(constant_values_1.Attributes.DEFAULT_LOGGER + callId + " ConnectInstanceId:" + amazonConnectInstanceID + " Loaded Contact Flow" + contactFlow);
        console.log(constant_values_1.Attributes.DEFAULT_LOGGER + callId + " ConnectInstanceId:" + amazonConnectInstanceID + " CallDetails:" + smaEvent.CallDetails);
        console.log(constant_values_1.Attributes.DEFAULT_LOGGER + callId + " ConnectInstanceId:" + amazonConnectInstanceID + " TransactionAttributes:" + transactionAttributes);
        if (transactionAttributes && transactionAttributes.currentFlowBlock) {
            console.log(constant_values_1.Attributes.DEFAULT_LOGGER + callId + " InvocationEventType:" + smaEvent.InvocationEventType);
            if (smaEvent.InvocationEventType === event_types_1.EventTypes.ACTION_SUCCESSFUL || smaEvent.InvocationEventType === event_types_1.EventTypes.CALL_ANSWERED) {
                if (smaEvent.ActionData.ReceivedDigits != null) {
                    const recieved_digits = smaEvent.ActionData.ReceivedDigits;
                    return await (0, condition_validation_1.processFlowConditionValidation)(smaEvent, transactionAttributes.currentFlowBlock, contactFlow, recieved_digits, amazonConnectInstanceID, bucketName, contextStore);
                }
                return await processFlowActionSuccess(smaEvent, transactionAttributes.currentFlowBlock, contactFlow, amazonConnectInstanceID, bucketName, contextStore);
            }
            else if (smaEvent.InvocationEventType === event_types_1.EventTypes.ACTION_FAILED || smaEvent.InvocationEventType === event_types_1.EventTypes.INVALID_LAMBDA_RESPONSE) {
                return await processFlowActionFailed(smaEvent, transactionAttributes.currentFlowBlock, contactFlow, amazonConnectInstanceID, bucketName, contextStore);
            }
            else {
                let disconnect = new disconnect_participant_1.DisconnectParticipant();
                return await disconnect.processFlowActionDisconnectParticipant(smaEvent, contextStore);
            }
        }
        else {
            if (smaEvent.InvocationEventType === event_types_1.EventTypes.NEW_INBOUND_CALL) {
                let contextAttributes = storeSystemAttributs(smaEvent, amazonConnectFlowID, amazonConnectFlowID);
                contextStore = {
                    "LoopCount": "0",
                    "TransferFlowARN": "",
                    "InvokeModuleARN": "",
                    "InvokationModuleNextAction": "",
                    "ActualFlowARN": "",
                    "SpeechAttributes": {},
                    "ContextAttributes": contextAttributes,
                    "TmpMap": {},
                    "PauseAction": null
                };
            }
            // We're at the root start from there
            return await processRootFlowBlock(smaEvent, contactFlow, amazonConnectInstanceID, bucketName, contextStore);
        }
    }
    catch (error) {
        console.log(constant_values_1.Attributes.DEFAULT_LOGGER + callId + " There is an Error in processing the SMA Event" + error.message);
        return null;
    }
}
exports.processFlow = processFlow;
/**
  * This function stores the System attributes in the Map, when new NEW_INBOUND_CALL is recieved
  * @param smaEvent
  * @param amazonConnectFlowID
  * @param amazonConnectInstanceID
  * @returns SMA Action
  */
async function storeSystemAttributs(smaEvent, amazonConnectFlowID, amazonConnectInstanceID) {
    const legA = (0, call_details_1.getLegACallDetails)(smaEvent);
    let contextAttributes = {
        "$.CustomerEndpoint.Address": legA.From,
        "$.SystemEndpoint.Address": legA.To,
        "$.InitiationMethod": legA.Direction,
        "$.ContactId": amazonConnectFlowID,
        "$.InstanceARN": amazonConnectInstanceID,
        "$.Channel": constant_values_1.Attributes.CHANNEL,
        "$.CustomerEndpoint.Type": constant_values_1.Attributes.CUSTOMER_ENDPOINT_TYPE,
        "$.SystemEndpoint.Type": constant_values_1.Attributes.SYSTEM_ENDPOINT_TYPE
    };
    return contextAttributes;
}
/**
  * This function is starting of the flow exection.
  * Get current action from the flow block and send to process flow action
  * @param smaEvent
  * @param contactFlow
  * @param TransactionAttributes
  * @param amazonConnectInstanceID
  * @param bucketName
  * @returns SMA Action
  */
async function processRootFlowBlock(smaEvent, contactFlow, amazonConnectInstanceID, bucketName, contextStore) {
    // OK, time to figure out the root of the flow
    let callId;
    try {
        const legA = (0, call_details_1.getLegACallDetails)(smaEvent);
        callId = legA.CallId;
        if (!callId)
            callId = smaEvent.ActionData.Parameters.CallId;
        if (contactFlow.StartAction) {
            const actions = contactFlow.Actions;
            console.log(constant_values_1.Attributes.DEFAULT_LOGGER + callId + " ConnectInstanceId:" + amazonConnectInstanceID + " Root Flow Block The actions are" + actions);
            if (actions && actions.length > 0) {
                const currentAction = (0, find_action_id_1.findActionByID)(actions, contactFlow.StartAction);
                let actionType = currentAction.Type;
                if (!Object.values(amazon_connect_actionTypes_1.AmazonConnectActions).includes(actionType)) {
                    return await (0, termination_action_1.terminatingFlowAction)(smaEvent, actionType);
                }
                console.log(constant_values_1.Attributes.DEFAULT_LOGGER + callId + " ConnectInstanceId:" + amazonConnectInstanceID + " Root Flow Block The current Action is " + currentAction.Type);
                if (currentAction) {
                    return await processFlowAction(smaEvent, currentAction, actions, amazonConnectInstanceID, bucketName, contextStore);
                }
            }
        }
    }
    catch (error) {
        console.error(constant_values_1.Attributes.DEFAULT_LOGGER + callId + " There is an Error in getting the Root Flow Block" + error.message);
        return await (0, termination_action_1.terminatingFlowAction)(smaEvent, "error");
    }
}
exports.processRootFlowBlock = processRootFlowBlock;
/**
  * This function process the flow actions and call the respective SMA Mapping Class based on the action type.
  * @param smaEvent
  * @param action
  * @param actions
  * @param amazonConnectInstanceID
  * @param bucketName
  * @returns SMA Action
  */
async function processFlowAction(smaEvent, action, actions, amazonConnectInstanceID, bucketName, contextStore) {
    console.log("ProcessFlowAction:" + action);
    switch (action.Type) {
        case amazon_connect_actionTypes_1.AmazonConnectActions.GET_PARTICIPANT_INPUT:
            let getParticipantInput = new get_participant_input_1.GetParticipantInput();
            return await getParticipantInput.processFlowActionGetParticipantInput(smaEvent, action, contextStore);
        case amazon_connect_actionTypes_1.AmazonConnectActions.MESSAGE_PARTICIPANT:
            let message_participant = new message_participant_1.MessageParticipant();
            return await message_participant.processFlowActionMessageParticipant(smaEvent, action, contextStore);
        case amazon_connect_actionTypes_1.AmazonConnectActions.DISCONNECT_PARTICIPANT:
            let disconnect = new disconnect_participant_1.DisconnectParticipant();
            return await disconnect.processFlowActionDisconnectParticipant(smaEvent, contextStore);
        case amazon_connect_actionTypes_1.AmazonConnectActions.WAIT:
            let wait = new wait_1.Wait();
            return await wait.processFlowActionWait(smaEvent, action, actions, amazonConnectInstanceID, bucketName, contextStore);
        case amazon_connect_actionTypes_1.AmazonConnectActions.UPDATE_CONTACT_RECORDING_BEHAVIOUR:
            let callRecording = new call_recording_1.CallRecording();
            return await callRecording.processFlowActionUpdateContactRecordingBehavior(smaEvent, action, contextStore);
        case amazon_connect_actionTypes_1.AmazonConnectActions.LOOP:
            let loop = new loop_1.Loop();
            return await loop.processFlowActionLoop(smaEvent, action, actions, amazonConnectInstanceID, bucketName, contextStore);
        case amazon_connect_actionTypes_1.AmazonConnectActions.TRANSFER_PARTICIPANT_TO_THIRD_PARTY:
            let transferThirdParty = new transfer_to_thirdparty_1.TransferTOThirdParty();
            return await transferThirdParty.processFlowActionTransferParticipantToThirdParty(smaEvent, action, contextStore);
        case amazon_connect_actionTypes_1.AmazonConnectActions.CONNECT_PARTICIPANT_WITH_LEX_BOT:
            let lexbot = new lex_bot_1.LexBot();
            return await lexbot.processFlowActionConnectParticipantWithLexBot(smaEvent, action, contextStore);
        case amazon_connect_actionTypes_1.AmazonConnectActions.TRANSFER_TO_FLOW:
            let transferToFlow = new transfer_flow_1.TrasferToFlow();
            return await transferToFlow.processFlowActionTransferToFlow(smaEvent, action, amazonConnectInstanceID, bucketName, contextStore);
        case amazon_connect_actionTypes_1.AmazonConnectActions.UPDATE_CONTACT_TEXT_TO_SPEECH:
            let updateVoice = new set_voice_1.SetVoice();
            return await updateVoice.processFlowActionUpdateContactTextToSpeechVoice(smaEvent, action, actions, amazonConnectInstanceID, bucketName, contextStore);
        case amazon_connect_actionTypes_1.AmazonConnectActions.INVOKE_LAMBDA_FUNCTION:
            let invokeLambda = new invoke_lambda_1.InvokeLambda();
            return await invokeLambda.processFlowActionInvokeLambdaFunction(smaEvent, action, actions, amazonConnectInstanceID, bucketName, contextStore);
        case amazon_connect_actionTypes_1.AmazonConnectActions.UPDATE_CONTACT_ATTRIBUTES:
            let update = new update_contact_attributes_1.UpdateContactAttrbts();
            return await update.processFlowActionUpdateContactAttributes(smaEvent, action, actions, amazonConnectInstanceID, bucketName, contextStore);
        case amazon_connect_actionTypes_1.AmazonConnectActions.COMPARE:
            let compare = new compare_attribute_1.CompareAttribute();
            return await compare.processFlowActionCompareContactAttributes(smaEvent, action, actions, amazonConnectInstanceID, bucketName, contextStore);
        case amazon_connect_actionTypes_1.AmazonConnectActions.INVOKE_FLOW_MODULE:
            let invoke = new invoke_module_1.InvokeModule();
            return await invoke.processFlowActionInvokeFlowModule(smaEvent, action, amazonConnectInstanceID, bucketName, contextStore);
        case amazon_connect_actionTypes_1.AmazonConnectActions.END_FLOW_MODULE_EXECUTION:
            let endModule = new end_module_1.EndModule();
            return await endModule.processFlowActionEndFlowModuleExecution(smaEvent, amazonConnectInstanceID, bucketName, contextStore);
        default:
            null;
    }
}
exports.processFlowAction = processFlowAction;
/**
  * After received success event from SMA,process the next action.
  * @param smaEvent
  * @param action
  * @param amazonConnectInstanceID
  * @param bucketName
  * @returns Process Flow Action
  */
async function processFlowActionSuccess(smaEvent, action, contactFlow, amazonConnectInstanceID, bucketName, contextStore) {
    let callId;
    try {
        const legA = (0, call_details_1.getLegACallDetails)(smaEvent);
        callId = legA.CallId;
        if (!callId)
            callId = smaEvent.ActionData.Parameters.CallId;
        let transactionAttributes = smaEvent.CallDetails.TransactionAttributes;
        if (action.Parameters && action.Parameters.StoreInput == "True") {
            smaEvent.CallDetails.TransactionAttributes = updateConnectContextStore(transactionAttributes, "StoredCustomerInput", smaEvent.ActionData.ReceivedDigits);
        }
        if (smaEvent.ActionData.IntentResult) {
            let intentName = smaEvent.ActionData.IntentResult.SessionState.Intent.Name;
            return await (0, condition_validation_1.processFlowConditionValidation)(smaEvent, transactionAttributes.currentFlowBlock, contactFlow, intentName, amazonConnectInstanceID, bucketName, contextStore);
        }
        const nextAction = (0, find_action_id_1.findActionByID)(contactFlow.Actions, action.Transitions.NextAction);
        let actionType = nextAction.Type;
        if (!Object.values(amazon_connect_actionTypes_1.AmazonConnectActions).includes(actionType)) {
            return await (0, termination_action_1.terminatingFlowAction)(smaEvent, actionType);
        }
        return await processFlowAction(smaEvent, nextAction, contactFlow.Actions, amazonConnectInstanceID, bucketName, smaEvent.CallDetails.TransactionAttributes[constant_values_1.Attributes.CONNECT_CONTEXT_STORE]);
    }
    catch (error) {
        console.error(constant_values_1.Attributes.DEFAULT_LOGGER + callId + " There is an Error in Proccessing the Success SMA Event " + error.message);
        return null;
    }
}
function updateConnectContextStore(transactionAttributes, key, value) {
    if (transactionAttributes[connectContextStore])
        transactionAttributes[connectContextStore][key] = value;
    else {
        transactionAttributes[connectContextStore] = {};
        transactionAttributes[connectContextStore][key] = value;
    }
    return transactionAttributes;
}
/**
  * After received failure event from SMA,process the next action.
  * @param smaEvent
  * @param action
  * @param amazonConnectInstanceID
  * @param bucketName
  * @returns Process Flow Action
  */
async function processFlowActionFailed(smaEvent, actionObj, contactFlow, amazonConnectInstanceID, bucketName, contextStore) {
    let callId;
    let smaAction1;
    try {
        const legA = (0, call_details_1.getLegACallDetails)(smaEvent);
        callId = legA.CallId;
        if (!callId)
            callId = smaEvent.ActionData.Parameters.CallId;
        let currentAction = contactFlow.Actions.find((action) => action.Identifier === actionObj.Identifier);
        let smaAction;
        let nextAction;
        if (smaEvent && smaEvent.ActionData.ErrorType.includes(error_types_1.ErrorTypes.INPUT_TIME_LIMIT_EXCEEDS) || smaEvent.ActionData.ErrorType.includes(error_types_1.ErrorTypes.INVALID_DIGITS_RECEIVED)) {
            nextAction = await (0, next_action_error_1.getNextActionForError)(currentAction, contactFlow.Actions, error_types_1.ErrorTypes.INPUT_TIME_LIMIT_EXCEEDS, smaEvent);
        }
        else if (smaEvent && smaEvent.ActionData.ErrorType.includes(error_types_1.ErrorTypes.NO_MATCHING_CONDITION)) {
            nextAction = await (0, next_action_error_1.getNextActionForError)(currentAction, contactFlow, error_types_1.ErrorTypes.NO_MATCHING_CONDITION, smaEvent);
        }
        else if (smaEvent && smaEvent.ActionData.ErrorType.includes(error_types_1.ErrorTypes.CONNECTION_TIME_LIMIT_EXCEEDED)) {
            nextAction = await (0, next_action_error_1.getNextActionForError)(currentAction, contactFlow, error_types_1.ErrorTypes.CONNECTION_TIME_LIMIT_EXCEEDED, smaEvent);
        }
        else if (smaEvent && smaEvent.ActionData.ErrorType.includes(error_types_1.ErrorTypes.CALL_FAILED)) {
            nextAction = await (0, next_action_error_1.getNextActionForError)(currentAction, contactFlow, error_types_1.ErrorTypes.CALL_FAILED, smaEvent);
        }
        else if (smaEvent && smaEvent.ActionData.ErrorType.includes(error_types_1.ErrorTypes.INVALID_PHONE_NUMBER)) {
            nextAction = await (0, next_action_error_1.getNextActionForError)(currentAction, contactFlow, error_types_1.ErrorTypes.INVALID_PHONE_NUMBER, smaEvent);
        }
        else {
            let count;
            for (let i = 0; i < currentAction.Transitions.Errors.length; i++) {
                if (currentAction.Transitions.Errors[i].ErrorType == error_types_1.ErrorTypes.NO_MATCHING_ERROR) {
                    count = i;
                    break;
                }
            }
            nextAction = (0, find_action_id_1.findActionByID)(contactFlow.Actions, currentAction.Transitions.Errors[count].NextAction);
            console.log(constant_values_1.Attributes.DEFAULT_LOGGER + callId + "Next Action identifier:" + currentAction.Transitions.Errors[count].NextAction);
        }
        let actionType = nextAction.Type;
        if (!Object.values(amazon_connect_actionTypes_1.AmazonConnectActions).includes(actionType)) {
            return await (0, termination_action_1.terminatingFlowAction)(smaEvent, actionType);
        }
        return await processFlowAction(smaEvent, nextAction, contactFlow.Actions, amazonConnectInstanceID, bucketName, contextStore);
    }
    catch (error) {
        console.error(constant_values_1.Attributes.DEFAULT_LOGGER + callId + " There is an Error in Proccessing the Failed SMA Event " + error.message);
        return null;
    }
}
