"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processFlowAction = exports.processRootFlowBlock = exports.processFlow = void 0;
const contact_flow_loader_1 = require("./contact-flow-loader");
const call_recording_1 = require("./SMA_Mapping_Actions/call-recording");
const compare_attribute_1 = require("./SMA_Mapping_Actions/compare-attribute");
const disconnect_participant_1 = require("./SMA_Mapping_Actions/disconnect-participant");
const end_module_1 = require("./SMA_Mapping_Actions/end-module");
const get_participant_input_1 = require("./SMA_Mapping_Actions/get-participant-input");
const invoke_lambda_1 = require("./SMA_Mapping_Actions/invoke-lambda");
const invoke_module_1 = require("./SMA_Mapping_Actions/invoke-module");
const lex_bot_1 = require("./SMA_Mapping_Actions/lex-bot");
const loop_1 = require("./SMA_Mapping_Actions/loop");
const message_participant_1 = require("./SMA_Mapping_Actions/message-participant");
const set_voice_1 = require("./SMA_Mapping_Actions/set-voice");
const transfer_flow_1 = require("./SMA_Mapping_Actions/transfer-flow");
const transfer_to_thirdparty_1 = require("./SMA_Mapping_Actions/transfer-to-thirdparty");
const update_contact_attributes_1 = require("./SMA_Mapping_Actions/update-contact-attributes");
const wait_1 = require("./SMA_Mapping_Actions/wait");
const amazon_connect_actionTypes_1 = require("./utility/amazon-connect-actionTypes");
const call_details_1 = require("./utility/call-details");
const condition_validation_1 = require("./utility/condition-validation");
const constant_values_1 = require("./utility/constant-values");
const error_types_1 = require("./utility/error-types");
const event_types_1 = require("./utility/event-types");
const find_action_id_1 = require("./utility/find-action-id");
const next_action_error_1 = require("./utility/next-action-error");
const termination_action_1 = require("./utility/termination-action");
const connectContextStore = "ConnectContextStore";
const defaultLogger = "SMA-Contact-Flow-Builder | Call ID - ";
let contextStore = {};
//let loopMap = new Map<string, string>(); // loop count
//let ContactFlowARNMap = new Map<string, string>(); //For Transfer flow maintaing , transfer flow id
//let InvokeModuleARNMap = new Map<string, string>(); // For module arn ind
//let InvokationModuleNextAction = new Map<string, string>(); // next action after module execution 
//let ActualFlowARN = new Map<string, string>(); // orginal contact flow
const SpeechAttributeMap = new Map();
const contextAttributes = new Map();
let tmpMap = new Map();
//let pauseAction: any;
/**
  * This function get connect flow data from contact flow loader
  * and send the connect flow data to respective functions.
  * @param smaEvent
  * @param amazonConnectInstanceID
  * @param amazonConnectFlowID
  * @param bucketName
  * @returns SMA Action
  */
async function processFlow(smaEvent, amazonConnectInstanceID, amazonConnectFlowID, bucketName) {
    let callId;
    try {
        let type = "Contact_Flow";
        const legA = (0, call_details_1.getLegACallDetails)(smaEvent);
        const transactionAttributes = smaEvent.CallDetails.TransactionAttributes;
        callId = legA.CallId;
        if (!callId)
            callId = smaEvent.ActionData.Parameters.CallId;
        if (transactionAttributes && transactionAttributes['connectContextStore']) {
            console.log("connectContextStore:" + "true");
            contextStore = transactionAttributes['connectContextStore'];
        }
        if (transactionAttributes && transactionAttributes['connectContextStore'] && !transactionAttributes['connectContextStore']['actualFlowARN']) {
            console.log("actualFlowARN:" + "true");
            transactionAttributes['connectContextStore']['actualFlowARN'] = amazonConnectFlowID;
        }
        if (transactionAttributes && transactionAttributes['connectContextStore'] && transactionAttributes['connectContextStore']['transferFlowARN']) {
            console.log("transferFlowARN:" + "true");
            amazonConnectFlowID = transactionAttributes['connectContextStore']['transferFlowARN'];
        }
        if (transactionAttributes && transactionAttributes['connectContextStore'] && transactionAttributes['connectContextStore']['invokeModuleARN']) {
            type = "Invoke_Module";
            console.log("invokeModuleARN:" + "true");
            amazonConnectFlowID = transactionAttributes['connectContextStore']['invokeModuleARN'];
        }
        const contactFlow = await (0, contact_flow_loader_1.loadContactFlow)(amazonConnectInstanceID, amazonConnectFlowID, bucketName, smaEvent, type);
        console.log(defaultLogger + callId + " ConnectInstanceId:" + amazonConnectInstanceID + " Loaded Contact Flow" + contactFlow);
        console.log(defaultLogger + callId + " ConnectInstanceId:" + amazonConnectInstanceID + " CallDetails:" + smaEvent.CallDetails);
        console.log(defaultLogger + callId + " ConnectInstanceId:" + amazonConnectInstanceID + " TransactionAttributes:" + transactionAttributes);
        if (transactionAttributes && transactionAttributes.currentFlowBlock) {
            console.log(defaultLogger + callId + " InvocationEventType:" + smaEvent.InvocationEventType);
            if (smaEvent.InvocationEventType === event_types_1.EventTypes.ACTION_SUCCESSFUL || smaEvent.InvocationEventType === event_types_1.EventTypes.CALL_ANSWERED) {
                if (smaEvent.ActionData.ReceivedDigits != null) {
                    const recieved_digits = smaEvent.ActionData.ReceivedDigits;
                    return await (0, condition_validation_1.processFlowConditionValidation)(smaEvent, transactionAttributes.currentFlowBlock, contactFlow, recieved_digits, amazonConnectInstanceID, bucketName, defaultLogger, contextStore);
                }
                return await processFlowActionSuccess(smaEvent, transactionAttributes.currentFlowBlock, contactFlow, amazonConnectInstanceID, bucketName, contextStore);
            }
            else if (smaEvent.InvocationEventType === event_types_1.EventTypes.ACTION_FAILED || smaEvent.InvocationEventType === event_types_1.EventTypes.INVALID_LAMBDA_RESPONSE) {
                return await processFlowActionFailed(smaEvent, transactionAttributes.currentFlowBlock, contactFlow, amazonConnectInstanceID, bucketName, contextStore);
            }
            else {
                let disconnect = new disconnect_participant_1.DisconnectParticipant();
                return await disconnect.processFlowActionDisconnectParticipant(smaEvent, transactionAttributes.currentFlowBlock, defaultLogger, contextStore);
                // processFlowActionDisconnectParticipant(smaEvent, transactionAttributes.currentFlowBlock);
            }
        }
        else {
            if (smaEvent.InvocationEventType === event_types_1.EventTypes.NEW_INBOUND_CALL) {
                storeSystemAttributs(smaEvent, amazonConnectFlowID, amazonConnectFlowID);
                contextStore = {
                    "loopCount": "0",
                    "transferFlowARN": "",
                    "invokeModuleARN": "",
                    "invokationModuleNextAction": "",
                    "actualFlowARN": "",
                    "speechAttributeMap": {},
                    "contextAttributes": {},
                    "tmpMap": {},
                    "pauseAction": null
                };
            }
            console.log("ContextStore Value: " + contextStore['loopCount']);
            // We're at the root start from there
            return await processRootFlowBlock(smaEvent, contactFlow, amazonConnectInstanceID, bucketName, contextStore);
        }
    }
    catch (error) {
        console.log(defaultLogger + callId + " There is an Error in processing the SMA Event" + error.message);
        return null;
    }
}
exports.processFlow = processFlow;
/**
  * This function stores the System attributes in the Map, when new NEW_INBOUND_CALL is recieved
  * @param smaEvent
  * @param amazonConnectFlowID
  * @param amazonConnectInstanceID
  * @returns SMA Action
  */
async function storeSystemAttributs(smaEvent, amazonConnectFlowID, amazonConnectInstanceID) {
    const legA = (0, call_details_1.getLegACallDetails)(smaEvent);
    contextAttributes.set("$.CustomerEndpoint.Address", legA.From);
    contextAttributes.set("$.SystemEndpoint.Address", legA.To);
    contextAttributes.set("$.InitiationMethod", legA.Direction);
    contextAttributes.set("$.ContactId", amazonConnectFlowID);
    contextAttributes.set("$.InstanceARN", amazonConnectInstanceID);
    contextAttributes.set("$.Channel", constant_values_1.Attributes.CHANNEL);
    contextAttributes.set("$.CustomerEndpoint.Type", constant_values_1.Attributes.CUSTOMER_ENDPOINT_TYPE);
    contextAttributes.set("$.SystemEndpoint.Type", constant_values_1.Attributes.SYSTEM_ENDPOINT_TYPE);
}
/**
  * This function is starting of the flow exection.
  * Get current action from the flow block and send to process flow action
  * @param smaEvent
  * @param contactFlow
  * @param _transactionAttributes
  * @param amazonConnectInstanceID
  * @param bucketName
  * @returns SMA Action
  */
async function processRootFlowBlock(smaEvent, contactFlow, amazonConnectInstanceID, bucketName, contextStore) {
    // OK, time to figure out the root of the flow
    let callId;
    try {
        const legA = (0, call_details_1.getLegACallDetails)(smaEvent);
        callId = legA.CallId;
        if (!callId)
            callId = smaEvent.ActionData.Parameters.CallId;
        if (contactFlow.StartAction) {
            const actions = contactFlow.Actions;
            console.log(defaultLogger + callId + " ConnectInstanceId:" + amazonConnectInstanceID + " Root Flow Block The actions are" + actions);
            if (actions && actions.length > 0) {
                const currentAction = (0, find_action_id_1.findActionByID)(actions, contactFlow.StartAction);
                let actionType = currentAction.Type;
                /*if (!AmazonConnectActions.hasOwnProperty(actionType)) {
                    return await terminatingFlowAction(smaEvent,  defaultLogger, actionType)
                }*/
                console.log(defaultLogger + callId + " ConnectInstanceId:" + amazonConnectInstanceID + " Root Flow Block The current Action is " + currentAction.Type);
                if (currentAction) {
                    console.log("Before Proccess Flow Action");
                    return await processFlowAction(smaEvent, currentAction, actions, amazonConnectInstanceID, bucketName, contextStore);
                }
            }
        }
    }
    catch (error) {
        console.error(defaultLogger + callId + " There is an Error in getting the Root Flow Block" + error.message);
        return await (0, termination_action_1.terminatingFlowAction)(smaEvent, defaultLogger, "error");
    }
}
exports.processRootFlowBlock = processRootFlowBlock;
/**
  * This function process the flow actions and call the respective SMA Mapping Class based on the action type.
  * @param smaEvent
  * @param action
  * @param actions
  * @param amazonConnectInstanceID
  * @param bucketName
  * @returns SMA Action
  */
async function processFlowAction(smaEvent, action, actions, amazonConnectInstanceID, bucketName, contextStore) {
    console.log("ProcessFlowAction:" + action);
    switch (action.Type) {
        case amazon_connect_actionTypes_1.AmazonConnectActions.GET_PARTICIPANT_INPUT:
            let getParticipantInput = new get_participant_input_1.GetParticipantInput();
            return await getParticipantInput.processFlowActionGetParticipantInput(smaEvent, action, defaultLogger, contextStore);
        case amazon_connect_actionTypes_1.AmazonConnectActions.MESSAGE_PARTICIPANT:
            let message_participant = new message_participant_1.MessageParticipant();
            return await message_participant.processFlowActionMessageParticipant(smaEvent, action, defaultLogger, contextStore);
        case amazon_connect_actionTypes_1.AmazonConnectActions.DISCONNECT_PARTICIPANT:
            let disconnect = new disconnect_participant_1.DisconnectParticipant();
            return await disconnect.processFlowActionDisconnectParticipant(smaEvent, action, defaultLogger, contextStore);
        case amazon_connect_actionTypes_1.AmazonConnectActions.WAIT:
            let wait = new wait_1.Wait();
            return await wait.processFlowActionWait(smaEvent, action, actions, amazonConnectInstanceID, bucketName, defaultLogger, contextStore);
        case amazon_connect_actionTypes_1.AmazonConnectActions.UPDATE_CONTACT_RECORDING_BEHAVIOUR:
            let callRecording = new call_recording_1.CallRecording();
            return await callRecording.processFlowActionUpdateContactRecordingBehavior(smaEvent, action, defaultLogger, contextStore);
        case amazon_connect_actionTypes_1.AmazonConnectActions.LOOP:
            let loop = new loop_1.Loop();
            return await loop.processFlowActionLoop(smaEvent, action, actions, amazonConnectInstanceID, bucketName, defaultLogger, contextStore);
        case amazon_connect_actionTypes_1.AmazonConnectActions.TRANSFER_PARTICIPANT_TO_THIRD_PARTY:
            let transferThirdParty = new transfer_to_thirdparty_1.TransferTOThirdParty();
            return await transferThirdParty.processFlowActionTransferParticipantToThirdParty(smaEvent, action, defaultLogger, contextStore);
        case amazon_connect_actionTypes_1.AmazonConnectActions.CONNECT_PARTICIPANT_WITH_LEX_BOT:
            let lexbot = new lex_bot_1.LexBot();
            return await lexbot.processFlowActionConnectParticipantWithLexBot(smaEvent, action, defaultLogger, contextStore);
        case amazon_connect_actionTypes_1.AmazonConnectActions.TRANSFER_TO_FLOW:
            let transferToFlow = new transfer_flow_1.TrasferToFlow();
            return await transferToFlow.processFlowActionTransferToFlow(smaEvent, action, amazonConnectInstanceID, bucketName, defaultLogger, contextStore);
        case amazon_connect_actionTypes_1.AmazonConnectActions.UPDATE_CONTACT_TEXT_TO_SPEECH:
            let updateVoice = new set_voice_1.SetVoice();
            return await updateVoice.processFlowActionUpdateContactTextToSpeechVoice(smaEvent, action, actions, amazonConnectInstanceID, bucketName, defaultLogger, contextStore);
        case amazon_connect_actionTypes_1.AmazonConnectActions.INVOKE_LAMBDA_FUNCTION:
            let invokeLambda = new invoke_lambda_1.InvokeLambda();
            return await invokeLambda.processFlowActionInvokeLambdaFunction(smaEvent, action, actions, amazonConnectInstanceID, bucketName, defaultLogger, contextStore);
        case amazon_connect_actionTypes_1.AmazonConnectActions.UPDATE_CONTACT_ATTRIBUTES:
            let update = new update_contact_attributes_1.UpdateContactAttrbts();
            return await update.processFlowActionUpdateContactAttributes(smaEvent, action, actions, amazonConnectInstanceID, bucketName, defaultLogger, contextStore);
        case amazon_connect_actionTypes_1.AmazonConnectActions.COMPARE:
            let compare = new compare_attribute_1.CompareAttribute();
            return await compare.processFlowActionCompareContactAttributes(smaEvent, action, actions, amazonConnectInstanceID, bucketName, defaultLogger, contextStore);
            let invoke = new invoke_module_1.InvokeModule();
            return await invoke.processFlowActionInvokeFlowModule(smaEvent, action, amazonConnectInstanceID, bucketName, defaultLogger, contextStore);
        case amazon_connect_actionTypes_1.AmazonConnectActions.END_FLOW_MODULE_EXECUTION:
            let endModule = new end_module_1.EndModule();
            return await endModule.processFlowActionEndFlowModuleExecution(smaEvent, amazonConnectInstanceID, bucketName, defaultLogger, contextStore);
        default:
            null;
    }
}
exports.processFlowAction = processFlowAction;
/**
  * After received success event from SMA,process the next action.
  * @param smaEvent
  * @param action
  * @param amazonConnectInstanceID
  * @param bucketName
  * @returns Process Flow Action
  */
async function processFlowActionSuccess(smaEvent, action, contactFlow, amazonConnectInstanceID, bucketName, contextStore) {
    let callId;
    try {
        const legA = (0, call_details_1.getLegACallDetails)(smaEvent);
        callId = legA.CallId;
        if (!callId)
            callId = smaEvent.ActionData.Parameters.CallId;
        let transactionAttributes = smaEvent.CallDetails.TransactionAttributes;
        if (action.Parameters && action.Parameters.StoreInput == "True") {
            smaEvent.CallDetails.TransactionAttributes = updateConnectContextStore(transactionAttributes, "StoredCustomerInput", smaEvent.ActionData.ReceivedDigits);
        }
        if (smaEvent.ActionData.IntentResult) {
            let intentName = smaEvent.ActionData.IntentResult.SessionState.Intent.Name;
            return await (0, condition_validation_1.processFlowConditionValidation)(smaEvent, transactionAttributes.currentFlowBlock, contactFlow, intentName, amazonConnectInstanceID, bucketName, defaultLogger, contextStore);
        }
        const nextAction = (0, find_action_id_1.findActionByID)(contactFlow.Actions, action.Transitions.NextAction);
        let actionType = nextAction.Type;
        /* if (!AmazonConnectActions.hasOwnProperty(actionType)) {
             return await terminatingFlowAction(smaEvent, defaultLogger, actionType)
         }*/
        console.log("Success: " + smaEvent.CallDetails.TransactionAttributes['connectContextStore']);
        return await processFlowAction(smaEvent, nextAction, contactFlow.Actions, amazonConnectInstanceID, bucketName, smaEvent.CallDetails.TransactionAttributes['connectContextStore']);
    }
    catch (error) {
        console.error(defaultLogger + callId + " There is an Error in Proccessing the Success SMA Event " + error.message);
        return null;
    }
}
function updateConnectContextStore(transactionAttributes, key, value) {
    if (transactionAttributes[connectContextStore])
        transactionAttributes[connectContextStore][key] = value;
    else {
        transactionAttributes[connectContextStore] = {};
        transactionAttributes[connectContextStore][key] = value;
    }
    return transactionAttributes;
}
/**
  * After received failure event from SMA,process the next action.
  * @param smaEvent
  * @param action
  * @param amazonConnectInstanceID
  * @param bucketName
  * @returns Process Flow Action
  */
async function processFlowActionFailed(smaEvent, actionObj, contactFlow, amazonConnectInstanceID, bucketName, contextStore) {
    let callId;
    let smaAction1;
    try {
        const legA = (0, call_details_1.getLegACallDetails)(smaEvent);
        callId = legA.CallId;
        if (!callId)
            callId = smaEvent.ActionData.Parameters.CallId;
        let currentAction = contactFlow.Actions.find((action) => action.Identifier === actionObj.Identifier);
        let smaAction;
        let nextAction;
        if (smaEvent && smaEvent.ActionData.ErrorType.includes(error_types_1.ErrorTypes.INPUT_TIME_LIMIT_EXCEEDS) || smaEvent.ActionData.ErrorType.includes(error_types_1.ErrorTypes.INVALID_DIGITS_RECEIVED)) {
            nextAction = await (0, next_action_error_1.getNextActionForError)(currentAction, contactFlow.Actions, error_types_1.ErrorTypes.INPUT_TIME_LIMIT_EXCEEDS, smaEvent, defaultLogger);
            smaAction = await (await processFlowAction(smaEvent, nextAction, contactFlow.Actions, amazonConnectInstanceID, bucketName, contextStore).Actions[0]);
        }
        else if (smaEvent && smaEvent.ActionData.ErrorType.includes(error_types_1.ErrorTypes.NO_MATCHING_CONDITION)) {
            nextAction = await (0, next_action_error_1.getNextActionForError)(currentAction, contactFlow, error_types_1.ErrorTypes.NO_MATCHING_CONDITION, smaEvent, defaultLogger);
            smaAction = await (await processFlowAction(smaEvent, nextAction, contactFlow.Actions, amazonConnectInstanceID, bucketName, contextStore).Actions[0]);
        }
        else if (smaEvent && smaEvent.ActionData.ErrorType.includes(error_types_1.ErrorTypes.CONNECTION_TIME_LIMIT_EXCEEDED)) {
            nextAction = await (0, next_action_error_1.getNextActionForError)(currentAction, contactFlow, error_types_1.ErrorTypes.CONNECTION_TIME_LIMIT_EXCEEDED, smaEvent, defaultLogger);
            smaAction = await (await processFlowAction(smaEvent, nextAction, contactFlow.Actions, amazonConnectInstanceID, bucketName, contextStore).Actions[0]);
        }
        else if (smaEvent && smaEvent.ActionData.ErrorType.includes(error_types_1.ErrorTypes.CALL_FAILED)) {
            nextAction = await (0, next_action_error_1.getNextActionForError)(currentAction, contactFlow, error_types_1.ErrorTypes.CALL_FAILED, smaEvent, defaultLogger);
            smaAction = await (await processFlowAction(smaEvent, nextAction, contactFlow.Actions, amazonConnectInstanceID, bucketName, contextStore).Actions[0]);
        }
        else if (smaEvent && smaEvent.ActionData.ErrorType.includes(error_types_1.ErrorTypes.INVALID_PHONE_NUMBER)) {
            nextAction = await (0, next_action_error_1.getNextActionForError)(currentAction, contactFlow, error_types_1.ErrorTypes.INVALID_PHONE_NUMBER, smaEvent, defaultLogger);
            smaAction = await (await processFlowAction(smaEvent, nextAction, contactFlow.Actions, amazonConnectInstanceID, bucketName, contextStore).Actions[0]);
        }
        else {
            let count;
            for (let i = 0; i < currentAction.Transitions.Errors.length; i++) {
                if (currentAction.Transitions.Errors[i].ErrorType == error_types_1.ErrorTypes.NO_MATCHING_ERROR) {
                    count = i;
                    break;
                }
            }
            nextAction = (0, find_action_id_1.findActionByID)(contactFlow.Actions, currentAction.Transitions.Errors[count].NextAction);
            console.log(defaultLogger + callId + "Next Action identifier:" + currentAction.Transitions.Errors[count].NextAction);
            smaAction = await (await processFlowAction(smaEvent, nextAction, contactFlow.Actions, amazonConnectInstanceID, bucketName, contextStore)).Actions[0];
        }
        let actionType = nextAction.Type;
        if (!amazon_connect_actionTypes_1.AmazonConnectActions.hasOwnProperty(actionType)) {
            return await (0, termination_action_1.terminatingFlowAction)(smaEvent, defaultLogger, actionType);
        }
        let pauseAction = contextStore['pauseAction'];
        if (pauseAction) {
            smaAction1 = pauseAction;
            pauseAction = null;
            return {
                "SchemaVersion": constant_values_1.Attributes.SCHEMA_VERSION,
                "Actions": [
                    smaAction1, smaAction
                ],
                "TransactionAttributes": {
                    "currentFlowBlock": nextAction,
                    "connectContextStore": contextStore
                }
            };
        }
        return {
            "SchemaVersion": constant_values_1.Attributes.SCHEMA_VERSION,
            "Actions": [
                smaAction
            ],
            "TransactionAttributes": {
                "currentFlowBlock": nextAction,
                "connectContextStore": contextStore
            }
        };
    }
    catch (error) {
        console.error(defaultLogger + callId + " There is an Error in Proccessing the Failed SMA Event " + error.message);
        return null;
    }
}
